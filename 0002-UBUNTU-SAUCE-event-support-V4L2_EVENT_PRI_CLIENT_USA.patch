From 077e0aa50d3dfffc18731740068e8e59e30c6fc8 Mon Sep 17 00:00:00 2001
From: Dimitri John Ledkov <dimitri.ledkov@canonical.com>
Date: Thu, 6 Oct 2022 15:01:47 +0100
Subject: [PATCH 2/2] UBUNTU: SAUCE: event: support V4L2_EVENT_PRI_CLIENT_USAGE

Gbp-Pq: 0006-UBUNTU-SAUCE-event-support-V4L2_EVENT_PRI_CLIENT_USA.patch.
---
 v4l2loopback.c | 63 +++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 62 insertions(+), 1 deletion(-)

diff --git a/v4l2loopback.c b/v4l2loopback.c
index 77291bc..8d3a22c 100644
--- a/v4l2loopback.c
+++ b/v4l2loopback.c
@@ -632,6 +632,14 @@ static void v4l2loopback_create_sysfs(struct video_device *vdev)
 	dev_err(&vdev->dev, "%s error: %d\n", __func__, res);
 }
 
+/* Event APIs */
+
+#define V4L2_EVENT_PRI_CLIENT_USAGE  V4L2_EVENT_PRIVATE_START
+
+struct v4l2_event_client_usage {
+	__u32 count;
+};
+
 /* global module data */
 struct v4l2_loopback_device *devs[MAX_DEVICES];
 
@@ -664,6 +672,7 @@ static struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)
 }
 
 /* forward declarations */
+static void client_usage_queue_event(struct video_device *vdev);
 static void init_buffers(struct v4l2_loopback_device *dev);
 static int allocate_buffers(struct v4l2_loopback_device *dev);
 static int free_buffers(struct v4l2_loopback_device *dev);
@@ -1745,6 +1754,7 @@ static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
 			return -EIO;
 		opener->type = READER;
 		dev->active_readers++;
+		client_usage_queue_event(dev->vdev);
 		return 0;
 	default:
 		return -EINVAL;
@@ -1773,6 +1783,7 @@ static int vidioc_streamoff(struct file *file, void *fh,
 		if (opener->type == READER) {
 			opener->type = 0;
 			dev->active_readers--;
+			client_usage_queue_event(dev->vdev);
 		}
 		break;
 	default:
@@ -1797,12 +1808,60 @@ static int vidiocgmbuf(struct file *file, void *fh, struct video_mbuf *p)
 }
 #endif
 
+static void client_usage_queue_event(struct video_device *vdev)
+{
+	struct v4l2_event ev;
+	struct v4l2_loopback_device *dev;
+
+	dev = container_of(vdev->v4l2_dev,
+			   struct v4l2_loopback_device, v4l2_dev);
+
+	memset(&ev, 0, sizeof(ev));
+	ev.type = V4L2_EVENT_PRI_CLIENT_USAGE;
+	((struct v4l2_event_client_usage*)&ev.u)->count =
+		dev->active_readers;
+
+	v4l2_event_queue(vdev, &ev);
+}
+
+static int client_usage_ops_add(struct v4l2_subscribed_event *sev,
+				unsigned elems)
+{
+	if (!(sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL))
+		return 0;
+
+	client_usage_queue_event(sev->fh->vdev);
+	return 0;
+}
+
+static void client_usage_ops_replace(struct v4l2_event *old,
+				     const struct v4l2_event *new)
+{
+	*((struct v4l2_event_client_usage*)&old->u) =
+		*((struct v4l2_event_client_usage*)&new->u);
+}
+
+static void client_usage_ops_merge(const struct v4l2_event *old,
+				   struct v4l2_event *new)
+{
+	*((struct v4l2_event_client_usage*)&new->u) =
+		*((struct v4l2_event_client_usage*)&old->u);
+}
+
+const struct v4l2_subscribed_event_ops client_usage_ops = {
+	.add = client_usage_ops_add,
+	.replace = client_usage_ops_replace,
+	.merge = client_usage_ops_merge,
+};
+
 static int vidioc_subscribe_event(struct v4l2_fh *fh,
 				  const struct v4l2_event_subscription *sub)
 {
 	switch (sub->type) {
 	case V4L2_EVENT_CTRL:
 		return v4l2_ctrl_subscribe_event(fh, sub);
+	case V4L2_EVENT_PRI_CLIENT_USAGE:
+		return v4l2_event_subscribe(fh, sub, 0, &client_usage_ops);
 	}
 
 	return -EINVAL;
@@ -2025,8 +2084,10 @@ static int v4l2_loopback_close(struct file *file)
 	kfree(opener);
 	if (is_writer)
 		dev->ready_for_output = 1;
-	if (is_reader)
+	if (is_reader) {
 		dev->active_readers--;
+		client_usage_queue_event(dev->vdev);
+	}
 	MARK();
 	return 0;
 }
-- 
2.38.1

