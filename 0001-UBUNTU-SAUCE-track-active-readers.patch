From abe07ef8c714e28cca05cd704fecd1fb68c47bae Mon Sep 17 00:00:00 2001
From: Dimitri John Ledkov <dimitri.ledkov@canonical.com>
Date: Thu, 6 Oct 2022 15:01:47 +0100
Subject: [PATCH 1/2] UBUNTU: SAUCE: track active readers

Gbp-Pq: 0005-track-active-readers.patch.
---
 v4l2loopback.c | 34 +++++++++++++++++++++++++++++-----
 1 file changed, 29 insertions(+), 5 deletions(-)

diff --git a/v4l2loopback.c b/v4l2loopback.c
index 7e47a43..77291bc 100644
--- a/v4l2loopback.c
+++ b/v4l2loopback.c
@@ -379,6 +379,7 @@ struct v4l2_loopback_device {
 	int ready_for_output; /* set to true when no writer is currently attached
 			       * this differs slightly from !ready_for_capture,
 			       * e.g. when using fallback images */
+	int active_readers;   /* increase if any reader starts streaming */
 	int announce_all_caps; /* set to false, if device caps (OUTPUT/CAPTURE)
 			       * should only be announced if the resp. "ready"
 			       * flag is set; default=TRUE */
@@ -1740,9 +1741,10 @@ static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
 		}
 		return 0;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		opener->type = READER;
 		if (!dev->ready_for_capture)
 			return -EIO;
+		opener->type = READER;
+		dev->active_readers++;
 		return 0;
 	default:
 		return -EINVAL;
@@ -1756,8 +1758,27 @@ static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
 static int vidioc_streamoff(struct file *file, void *fh,
 			    enum v4l2_buf_type type)
 {
+	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_opener *opener;
+
 	MARK();
 	dprintk("%d\n", type);
+
+	dev = v4l2loopback_getdevice(file);
+	opener = fh_to_opener(fh);
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		break;
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (opener->type == READER) {
+			opener->type = 0;
+			dev->active_readers--;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -1980,14 +2001,16 @@ static int v4l2_loopback_close(struct file *file)
 {
 	struct v4l2_loopback_opener *opener;
 	struct v4l2_loopback_device *dev;
-	int iswriter = 0;
+	int is_writer = 0, is_reader = 0;
 	MARK();
 
 	opener = fh_to_opener(file->private_data);
 	dev = v4l2loopback_getdevice(file);
 
 	if (WRITER == opener->type)
-		iswriter = 1;
+		is_writer = 1;
+	if (READER == opener->type)
+		is_reader = 1;
 
 	atomic_dec(&dev->open_count);
 	if (dev->open_count.counter == 0) {
@@ -2000,9 +2023,10 @@ static int v4l2_loopback_close(struct file *file)
 	v4l2_fh_exit(&opener->fh);
 
 	kfree(opener);
-	if (iswriter) {
+	if (is_writer)
 		dev->ready_for_output = 1;
-	}
+	if (is_reader)
+		dev->active_readers--;
 	MARK();
 	return 0;
 }
-- 
2.38.1

